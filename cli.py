#!/usr/bin/env python3
"""CLI for 127.0.0.1 MCP server.

Generated by: fastmcp generate-cli http://127.0.0.1:8000/mcp
"""

import json
import sys
from typing import Annotated

import cyclopts
import mcp.types
from rich.console import Console

from fastmcp import Client

# Modify this to change how the CLI connects to the MCP server.
CLIENT_SPEC = "http://127.0.0.1:8000/mcp"

app = cyclopts.App(name="127.0.0.1", help="CLI for 127.0.0.1 MCP server")
call_tool_app = cyclopts.App(name="call-tool", help="Call a tool on the server")
app.command(call_tool_app)

console = Console()


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _print_tool_result(result):
    if result.is_error:
        for block in result.content:
            if isinstance(block, mcp.types.TextContent):
                console.print(f"[bold red]Error:[/bold red] {block.text}")
            else:
                console.print(f"[bold red]Error:[/bold red] {block}")
        sys.exit(1)

    if result.structured_content is not None:
        console.print_json(json.dumps(result.structured_content))
        return

    for block in result.content:
        if isinstance(block, mcp.types.TextContent):
            console.print(block.text)
        elif isinstance(block, mcp.types.ImageContent):
            size = len(block.data) * 3 // 4
            console.print(f"[dim][Image: {block.mimeType}, ~{size} bytes][/dim]")
        elif isinstance(block, mcp.types.AudioContent):
            size = len(block.data) * 3 // 4
            console.print(f"[dim][Audio: {block.mimeType}, ~{size} bytes][/dim]")


async def _call_tool(tool_name: str, arguments: dict) -> None:
    # Filter out None values and empty lists (defaults for optional array params)
    filtered = {
        k: v
        for k, v in arguments.items()
        if v is not None and (not isinstance(v, list) or len(v) > 0)
    }
    async with Client(CLIENT_SPEC) as client:
        result = await client.call_tool(tool_name, filtered, raise_on_error=False)
        _print_tool_result(result)
        if result.is_error:
            sys.exit(1)


# ---------------------------------------------------------------------------
# List / read commands
# ---------------------------------------------------------------------------


@app.command
async def list_tools() -> None:
    """List available tools."""
    async with Client(CLIENT_SPEC) as client:
        tools = await client.list_tools()
        if not tools:
            console.print("[dim]No tools found.[/dim]")
            return
        for tool in tools:
            sig_parts = []
            props = tool.inputSchema.get("properties", {})
            required = set(tool.inputSchema.get("required", []))
            for pname, pschema in props.items():
                ptype = pschema.get("type", "string")
                if pname in required:
                    sig_parts.append(f"{pname}: {ptype}")
                else:
                    sig_parts.append(f"{pname}: {ptype} = ...")
            sig = f"{tool.name}({', '.join(sig_parts)})"
            console.print(f"  [cyan]{sig}[/cyan]")
            if tool.description:
                console.print(f"    {tool.description}")
            console.print()


@app.command
async def list_resources() -> None:
    """List available resources."""
    async with Client(CLIENT_SPEC) as client:
        resources = await client.list_resources()
        if not resources:
            console.print("[dim]No resources found.[/dim]")
            return
        for r in resources:
            console.print(f"  [cyan]{r.uri}[/cyan]")
            desc_parts = [r.name or "", r.description or ""]
            desc = " — ".join(p for p in desc_parts if p)
            if desc:
                console.print(f"    {desc}")
        console.print()


@app.command
async def list_resource_templates() -> None:
    """List available resources templates."""
    async with Client(CLIENT_SPEC) as client:
        resources = await client.list_resource_templates()
        if not resources:
            console.print("[dim]No resources templates found.[/dim]")
            return
        for r in resources:
            console.print(f"  [cyan]{r.uriTemplate}[/cyan]")
            desc_parts = [r.name or "", r.description or ""]
            desc = " — ".join(p for p in desc_parts if p)
            if desc:
                console.print(f"    {desc}")
        console.print()


@app.command
async def read_resource(
    uri: Annotated[str, cyclopts.Parameter(help="Resource URI")],
) -> None:
    """Read a resource by URI."""
    console.print(f"Reading resource {uri}")

    async with Client(CLIENT_SPEC) as client:
        contents = await client.read_resource(uri)
        for block in contents:
            if isinstance(block, mcp.types.TextResourceContents):
                console.print(block.text)
            elif isinstance(block, mcp.types.BlobResourceContents):
                size = len(block.blob) * 3 // 4
                console.print(f"[dim][Blob: {block.mimeType}, ~{size} bytes][/dim]")


@app.command
async def list_prompts() -> None:
    """List available prompts."""
    async with Client(CLIENT_SPEC) as client:
        prompts = await client.list_prompts()
        if not prompts:
            console.print("[dim]No prompts found.[/dim]")
            return
        for p in prompts:
            args_str = ""
            if p.arguments:
                parts = [a.name for a in p.arguments]
                args_str = f"({', '.join(parts)})"
            console.print(f"  [cyan]{p.name}{args_str}[/cyan]")
            if p.description:
                console.print(f"    {p.description}")
        console.print()


@app.command
async def get_prompt(
    name: Annotated[str, cyclopts.Parameter(help="Prompt name")],
    *arguments: str,
) -> None:
    """Get a prompt by name. Pass arguments as key=value pairs."""
    parsed: dict[str, str] = {}
    for arg in arguments:
        if "=" not in arg:
            console.print(
                f"[bold red]Error:[/bold red] Invalid argument {arg!r} — expected key=value"
            )
            sys.exit(1)
        key, value = arg.split("=", 1)
        parsed[key] = value

    async with Client(CLIENT_SPEC) as client:
        result = await client.get_prompt(name, parsed or None)
        for msg in result.messages:
            console.print(f"[bold]{msg.role}:[/bold]")
            if isinstance(msg.content, mcp.types.TextContent):
                console.print(f"  {msg.content.text}")
            elif isinstance(msg.content, mcp.types.ImageContent):
                size = len(msg.content.data) * 3 // 4
                console.print(
                    f"  [dim][Image: {msg.content.mimeType}, ~{size} bytes][/dim]"
                )
            else:
                console.print(f"  {msg.content}")
            console.print()


if __name__ == "__main__":
    app()
